{"ast":null,"code":"import { withScope, captureException, showReportDialog } from '@sentry/browser';\nimport { logger } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nvar _jsxFileName = \"/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/errorboundary.tsx\";\n\nfunction isAtLeastReact17(version) {\n  var major = version.match(/^([^.]+)/);\n  return major !== null && parseInt(major[0]) >= 17;\n}\n\nvar UNKNOWN_COMPONENT = 'unknown';\nvar INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null\n};\n/**\n * A ErrorBoundary component that logs errors to Sentry. Requires React >= 16.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\n\nclass ErrorBoundary extends React.Component {\n  constructor() {\n    super(...arguments);\n\n    ErrorBoundary.prototype.__init.call(this);\n\n    ErrorBoundary.prototype.__init2.call(this);\n  }\n\n  __init() {\n    this.state = INITIAL_STATE;\n  }\n\n  componentDidCatch(error, _ref) {\n    let {\n      componentStack\n    } = _ref;\n    const {\n      beforeCapture,\n      onError,\n      showDialog,\n      dialogOptions\n    } = this.props;\n    withScope(scope => {\n      // If on React version >= 17, create stack trace from componentStack param and links\n      // to to the original error using `error.cause` otherwise relies on error param for stacktrace.\n      // Linking errors requires the `LinkedErrors` integration be enabled.\n      if (isAtLeastReact17(React.version)) {\n        var errorBoundaryError = new Error(error.message);\n        errorBoundaryError.name = `React ErrorBoundary ${errorBoundaryError.name}`;\n        errorBoundaryError.stack = componentStack; // Using the `LinkedErrors` integration to link the errors together.\n\n        error.cause = errorBoundaryError;\n      }\n\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n\n      var eventId = captureException(error, {\n        contexts: {\n          react: {\n            componentStack\n          }\n        }\n      });\n\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n\n      if (showDialog) {\n        showReportDialog({ ...dialogOptions,\n          eventId\n        });\n      } // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n\n\n      this.setState({\n        error,\n        componentStack,\n        eventId\n      });\n    });\n  }\n\n  componentDidMount() {\n    const {\n      onMount\n    } = this.props;\n\n    if (onMount) {\n      onMount();\n    }\n  }\n\n  componentWillUnmount() {\n    const {\n      error,\n      componentStack,\n      eventId\n    } = this.state;\n    const {\n      onUnmount\n    } = this.props;\n\n    if (onUnmount) {\n      onUnmount(error, componentStack, eventId);\n    }\n  }\n\n  __init2() {\n    this.resetErrorBoundary = () => {\n      const {\n        onReset\n      } = this.props;\n      const {\n        error,\n        componentStack,\n        eventId\n      } = this.state;\n\n      if (onReset) {\n        onReset(error, componentStack, eventId);\n      }\n\n      this.setState(INITIAL_STATE);\n    };\n  }\n\n  render() {\n    const {\n      fallback,\n      children\n    } = this.props;\n    const {\n      error,\n      componentStack,\n      eventId\n    } = this.state;\n\n    if (error) {\n      let element = undefined;\n\n      if (typeof fallback === 'function') {\n        element = fallback({\n          error,\n          componentStack,\n          resetError: this.resetErrorBoundary,\n          eventId\n        });\n      } else {\n        element = fallback;\n      }\n\n      if (React.isValidElement(element)) {\n        return element;\n      }\n\n      if (fallback) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('fallback did not produce a valid ReactElement');\n      } // Fail gracefully if no fallback provided or is not valid\n\n\n      return null;\n    }\n\n    if (typeof children === 'function') {\n      return children();\n    }\n\n    return children;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction withErrorBoundary(WrappedComponent, errorBoundaryOptions) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  var componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  var Wrapped = props => React.createElement(ErrorBoundary, { ...errorBoundaryOptions,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 168\n    }\n  }, React.createElement(WrappedComponent, { ...props,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 169\n    }\n  })); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n\n  Wrapped.displayName = `errorBoundary(${componentDisplayName})`; // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\nexport { ErrorBoundary, UNKNOWN_COMPONENT, isAtLeastReact17, withErrorBoundary };","map":{"version":3,"mappings":";;;;AAAA;;;EAMA;EACA;AACA;;;AA+CA;EACAA,oBADA;EAEAC,WAFA;EAGAC;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;;AACA;EAAAC;IAAA;;IAAAC;;IAAAA;EAAA;;EACAC;IAAA;EAAA;;EAEAC;IAAA;MAAAN;IAAA;IACA;MAAAO;MAAAC;MAAAC;MAAAC;IAAA;IAEAC;MACA;MACA;MACA;MACA;QACA;QACAC;QACAA,0CAHA,CAKA;;QACAX;MACA;;MAEA;QACAM;MACA;;MACA;QAAAM;UAAAC;YAAAd;UAAA;QAAA;MAAA;;MACA;QACAQ;MACA;;MACA;QACAO;UAAAb;QAAA;MACA,CAtBA,CAwBA;MACA;;;MACA;QAAAD;QAAAD;QAAAE;MAAA;IACA,CA3BA;EA4BA;;EAEAc;IACA;MAAAC;IAAA;;IACA;MACAA;IACA;EACA;;EAEAC;IACA;MAAAjB;MAAAD;MAAAE;IAAA;IACA;MAAAiB;IAAA;;IACA;MACAA;IACA;EACA;;EAEAC;IAAA;MACA;QAAAC;MAAA;MACA;QAAApB;QAAAD;QAAAE;MAAA;;MACA;QACAmB;MACA;;MACA;IACA,CAPA;EAOA;;EAEAC;IACA;MAAAC;MAAAC;IAAA;IACA;MAAAvB;MAAAD;MAAAE;IAAA;;IAEA;MACA;;MACA;QACAuB;UAAAxB;UAAAD;UAAA0B;UAAAxB;QAAA;MACA,CAFA,MAEA;QACAuB;MACA;;MAEA;QACA;MACA;;MAEA;QACA;MACA,CAdA,CAgBA;;;MACA;IACA;;IAEA;MACA;IACA;;IACA;EACA;;AAxFA,C,CA2FA;;;AACA,2BACAE,gBADA,EAEAC,oBAFA,EAGA;EACA;EACA;;EAEA,uBACAC;IAAAC;IAAAC;MAAAC;MAAAC;IAAA;EAAA,GACAJ;IAAAC;IAAAC;MAAAC;MAAAC;IAAA;EAAA,EADA,CADA,CAJA,CAUA;;;EACAC,+DAXA,CAaA;EACA;;EACAC;EACA;AACA","names":["componentStack","error","eventId","constructor","ErrorBoundary","__init","componentDidCatch","beforeCapture","onError","showDialog","dialogOptions","withScope","errorBoundaryError","contexts","react","showReportDialog","componentDidMount","onMount","componentWillUnmount","onUnmount","__init2","onReset","render","fallback","children","element","resetError","WrappedComponent","errorBoundaryOptions","React","__self","__source","fileName","lineNumber","Wrapped","hoistNonReactStatics"],"sources":["C:\\Users\\Somayeh\\Documents\\GitHub\\ReactProject\\node_modules\\@sentry\\src\\errorboundary.tsx"],"sourcesContent":["import { captureException, ReportDialogOptions, Scope, showReportDialog, withScope } from '@sentry/browser';\nimport { logger } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\n\nexport function isAtLeastReact17(version: string): boolean {\n  const major = version.match(/^([^.]+)/);\n  return major !== null && parseInt(major[0]) >= 17;\n}\n\nexport const UNKNOWN_COMPONENT = 'unknown';\n\nexport type FallbackRender = (errorData: {\n  error: Error;\n  componentStack: string | null;\n  eventId: string | null;\n  resetError(): void;\n}) => React.ReactElement;\n\nexport type ErrorBoundaryProps = {\n  children?: React.ReactNode | (() => React.ReactNode);\n  /** If a Sentry report dialog should be rendered on error */\n  showDialog?: boolean;\n  /**\n   * Options to be passed into the Sentry report dialog.\n   * No-op if {@link showDialog} is false.\n   */\n  dialogOptions?: ReportDialogOptions;\n  /**\n   * A fallback component that gets rendered when the error boundary encounters an error.\n   *\n   * Can either provide a React Component, or a function that returns React Component as\n   * a valid fallback prop. If a function is provided, the function will be called with\n   * the error, the component stack, and an function that resets the error boundary on error.\n   *\n   */\n  fallback?: React.ReactElement | FallbackRender;\n  /** Called when the error boundary encounters an error */\n  onError?(error: Error, componentStack: string, eventId: string): void;\n  /** Called on componentDidMount() */\n  onMount?(): void;\n  /** Called if resetError() is called from the fallback render props function  */\n  onReset?(error: Error | null, componentStack: string | null, eventId: string | null): void;\n  /** Called on componentWillUnmount() */\n  onUnmount?(error: Error | null, componentStack: string | null, eventId: string | null): void;\n  /** Called before the error is captured by Sentry, allows for you to add tags or context using the scope */\n  beforeCapture?(scope: Scope, error: Error | null, componentStack: string | null): void;\n};\n\ntype ErrorBoundaryState = {\n  componentStack: React.ErrorInfo['componentStack'] | null;\n  error: Error | null;\n  eventId: string | null;\n};\n\nconst INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null,\n};\n\n/**\n * A ErrorBoundary component that logs errors to Sentry. Requires React >= 16.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  public state: ErrorBoundaryState = INITIAL_STATE;\n\n  public componentDidCatch(error: Error & { cause?: Error }, { componentStack }: React.ErrorInfo): void {\n    const { beforeCapture, onError, showDialog, dialogOptions } = this.props;\n\n    withScope(scope => {\n      // If on React version >= 17, create stack trace from componentStack param and links\n      // to to the original error using `error.cause` otherwise relies on error param for stacktrace.\n      // Linking errors requires the `LinkedErrors` integration be enabled.\n      if (isAtLeastReact17(React.version)) {\n        const errorBoundaryError = new Error(error.message);\n        errorBoundaryError.name = `React ErrorBoundary ${errorBoundaryError.name}`;\n        errorBoundaryError.stack = componentStack;\n\n        // Using the `LinkedErrors` integration to link the errors together.\n        error.cause = errorBoundaryError;\n      }\n\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n      const eventId = captureException(error, { contexts: { react: { componentStack } } });\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n      if (showDialog) {\n        showReportDialog({ ...dialogOptions, eventId });\n      }\n\n      // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n      this.setState({ error, componentStack, eventId });\n    });\n  }\n\n  public componentDidMount(): void {\n    const { onMount } = this.props;\n    if (onMount) {\n      onMount();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    const { error, componentStack, eventId } = this.state;\n    const { onUnmount } = this.props;\n    if (onUnmount) {\n      onUnmount(error, componentStack, eventId);\n    }\n  }\n\n  public resetErrorBoundary: () => void = () => {\n    const { onReset } = this.props;\n    const { error, componentStack, eventId } = this.state;\n    if (onReset) {\n      onReset(error, componentStack, eventId);\n    }\n    this.setState(INITIAL_STATE);\n  };\n\n  public render(): React.ReactNode {\n    const { fallback, children } = this.props;\n    const { error, componentStack, eventId } = this.state;\n\n    if (error) {\n      let element: React.ReactElement | undefined = undefined;\n      if (typeof fallback === 'function') {\n        element = fallback({ error, componentStack, resetError: this.resetErrorBoundary, eventId });\n      } else {\n        element = fallback;\n      }\n\n      if (React.isValidElement(element)) {\n        return element;\n      }\n\n      if (fallback) {\n        __DEBUG_BUILD__ && logger.warn('fallback did not produce a valid ReactElement');\n      }\n\n      // Fail gracefully if no fallback provided or is not valid\n      return null;\n    }\n\n    if (typeof children === 'function') {\n      return (children as () => React.ReactNode)();\n    }\n    return children;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorBoundary<P extends Record<string, any>>(\n  WrappedComponent: React.ComponentType<P>,\n  errorBoundaryOptions: ErrorBoundaryProps,\n): React.FC<P> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  const Wrapped: React.FC<P> = (props: P) => (\n    <ErrorBoundary {...errorBoundaryOptions}>\n      <WrappedComponent {...props} />\n    </ErrorBoundary>\n  );\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  Wrapped.displayName = `errorBoundary(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\nexport { ErrorBoundary, withErrorBoundary };\n"]},"metadata":{},"sourceType":"module"}