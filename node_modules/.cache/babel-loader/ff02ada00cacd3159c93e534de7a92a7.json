{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Somayeh\\\\Downloads\\\\Video\\\\ReactMosh\\\\New folder\\\\ReactPro\\\\my-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:\\\\Users\\\\Somayeh\\\\Downloads\\\\Video\\\\ReactMosh\\\\New folder\\\\ReactPro\\\\my-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { arrayify, logger } from '@sentry/utils';\nvar installedIntegrations = [];\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\n\nfunction filterDuplicates(integrations) {\n  var integrationsByName = {};\n  integrations.forEach(function (currentInstance) {\n    var name = currentInstance.name;\n    var existingInstance = integrationsByName[name]; // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n  return Object.values(integrationsByName);\n}\n/** Gets integrations to install */\n\n\nfunction getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations || [];\n  var userIntegrations = options.integrations; // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n\n  defaultIntegrations.forEach(function (integration) {\n    integration.isDefaultInstance = true;\n  });\n  var integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [].concat(_toConsumableArray(defaultIntegrations), _toConsumableArray(userIntegrations));\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  var finalIntegrations = filterDuplicates(integrations); // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend`. It therefore\n  // has to run after all other integrations, so that the changes of all event processors will be reflected in the\n  // printed values. For lack of a more elegant way to guarantee that, we therefore locate it and, assuming it exists,\n  // pop it out of its current spot and shove it onto the end of the array.\n\n  var debugIndex = finalIntegrations.findIndex(function (integration) {\n    return integration.name === 'Debug';\n  });\n\n  if (debugIndex !== -1) {\n    var _finalIntegrations$sp = finalIntegrations.splice(debugIndex, 1),\n        _finalIntegrations$sp2 = _slicedToArray(_finalIntegrations$sp, 1),\n        debugInstance = _finalIntegrations$sp2[0];\n\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\n\n\nfunction setupIntegrations(integrations) {\n  var integrationIndex = {};\n  integrations.forEach(function (integration) {\n    integrationIndex[integration.name] = integration;\n\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n      installedIntegrations.push(integration.name);\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(\"Integration installed: \".concat(integration.name));\n    }\n  });\n  return integrationIndex;\n}\n\nexport { getIntegrationsToSetup, installedIntegrations, setupIntegrations };","map":null,"metadata":{},"sourceType":"module"}