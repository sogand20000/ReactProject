{"ast":null,"code":"import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { arrayify, logger } from '@sentry/utils';\nvar installedIntegrations = [];\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\n\nfunction filterDuplicates(integrations) {\n  var integrationsByName = {};\n  integrations.forEach(currentInstance => {\n    const {\n      name\n    } = currentInstance;\n    var existingInstance = integrationsByName[name]; // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n  return Object.values(integrationsByName);\n}\n/** Gets integrations to install */\n\n\nfunction getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations || [];\n  var userIntegrations = options.integrations; // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  var finalIntegrations = filterDuplicates(integrations); // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend`. It therefore\n  // has to run after all other integrations, so that the changes of all event processors will be reflected in the\n  // printed values. For lack of a more elegant way to guarantee that, we therefore locate it and, assuming it exists,\n  // pop it out of its current spot and shove it onto the end of the array.\n\n  var debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');\n\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\n\n\nfunction setupIntegrations(integrations) {\n  var integrationIndex = {};\n  integrations.forEach(integration => {\n    integrationIndex[integration.name] = integration;\n\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n      installedIntegrations.push(integration.name);\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Integration installed: ${integration.name}`);\n    }\n  });\n  return integrationIndex;\n}\n\nexport { getIntegrationsToSetup, installedIntegrations, setupIntegrations };","map":{"version":3,"mappings":";;;AAYA;;AAKA;AACA;AACA;AACA;AACA;AACA;;AACA;EACA;EAEAA;IACA;MAAAC;IAAA;IAEA,gDAHA,CAKA;IACA;;IACA;MACA;IACA;;IAEAC;EACA,CAZA;EAcA;AACA;AAEA;;;;EAEA;EACA,6CAEA;;EACAC;IACAC;EACA,CAFA;EAIA;;EAEA;IACAJ;EACA,CAFA,MAEA;IACAA;EACA,CAFA,MAEA;IACAA;EACA;;EAEA,wDAEA;EACA;EACA;EACA;;EACA;;EACA;IACA;IACAK;EACA;;EAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;EAEA;EAEAL;IACAM;;IAEA;MACAF;MACAG;MACA;IACA;EACA,CARA;EAUA;AACA","names":["integrations","name","integrationsByName","defaultIntegrations","integration","finalIntegrations","integrationIndex","installedIntegrations"],"sources":["C:\\Users\\Somayeh\\Downloads\\Video\\ReactMosh\\New folder\\ReactPro\\my-app\\node_modules\\@sentry\\src\\integration.ts"],"sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { Integration, Options } from '@sentry/types';\nimport { arrayify, logger } from '@sentry/utils';\n\ndeclare module '@sentry/types' {\n  interface Integration {\n    isDefaultInstance?: boolean;\n  }\n}\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n};\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  const integrationsByName: { [key: string]: Integration } = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations: Integration[];\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend`. It therefore\n  // has to run after all other integrations, so that the changes of all event processors will be reflected in the\n  // printed values. For lack of a more elegant way to guarantee that, we therefore locate it and, assuming it exists,\n  // pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(integrations: Integration[]): IntegrationIndex {\n  const integrationIndex: IntegrationIndex = {};\n\n  integrations.forEach(integration => {\n    integrationIndex[integration.name] = integration;\n\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n      installedIntegrations.push(integration.name);\n      __DEBUG_BUILD__ && logger.log(`Integration installed: ${integration.name}`);\n    }\n  });\n\n  return integrationIndex;\n}\n"]},"metadata":{},"sourceType":"module"}