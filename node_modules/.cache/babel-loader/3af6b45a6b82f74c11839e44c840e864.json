{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\Somayeh\\\\Downloads\\\\Video\\\\ReactMosh\\\\New folder\\\\ReactPro\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"C:\\\\Users\\\\Somayeh\\\\Downloads\\\\Video\\\\ReactMosh\\\\New folder\\\\ReactPro\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { _optionalChain } from './buildPolyfills';\nimport { isString, isPlainObject } from './is.js';\nimport { normalize } from './normalize.js';\nimport { stripUrlQueryAndFragment } from './url.js';\nvar DEFAULT_INCLUDES = {\n  ip: false,\n  request: true,\n  transaction: true,\n  user: true\n};\nvar DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\nvar DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];\n/**\n * Sets parameterized route as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\n\nfunction addRequestDataToTransaction(transaction, req, deps) {\n  if (!transaction) return;\n\n  if (!transaction.metadata.source || transaction.metadata.source === 'url') {\n    // Attempt to grab a parameterized route off of the request\n    transaction.setName.apply(transaction, _toConsumableArray(extractPathForTransaction(req, {\n      path: true,\n      method: true\n    })));\n  }\n\n  transaction.setData('url', req.originalUrl || req.url);\n\n  if (req.baseUrl) {\n    transaction.setData('baseUrl', req.baseUrl);\n  }\n\n  transaction.setData('query', extractQueryParams(req, deps));\n}\n/**\n * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.\n * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.\n *\n * Additionally, this function determines and returns the transaction name source\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req A request object\n * @param options What to include in the transaction name (method, path, or a custom route name to be\n *                used instead of the request's route)\n *\n * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')\n */\n\n\nfunction extractPathForTransaction(req) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var method = req.method && req.method.toUpperCase();\n  var path = '';\n  var source = 'url'; // Check to see if there's a parameterized route we can use (as there is in Express)\n\n  if (options.customRoute || req.route) {\n    path = options.customRoute || \"\".concat(req.baseUrl || '').concat(req.route && req.route.path);\n    source = 'route';\n  } // Otherwise, just take the original URL\n  else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  var name = '';\n\n  if (options.method && method) {\n    name += method;\n  }\n\n  if (options.method && options.path) {\n    name += ' ';\n  }\n\n  if (options.path && path) {\n    name += path;\n  }\n\n  return [name, source];\n}\n/** JSDoc */\n\n\nfunction extractTransaction(req, type) {\n  switch (type) {\n    case 'path':\n      {\n        return extractPathForTransaction(req, {\n          path: true\n        })[0];\n      }\n\n    case 'handler':\n      {\n        return req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name || '<anonymous>';\n      }\n\n    case 'methodPath':\n    default:\n      {\n        return extractPathForTransaction(req, {\n          path: true,\n          method: true\n        })[0];\n      }\n  }\n}\n/** JSDoc */\n\n\nfunction extractUserData(user, keys) {\n  var extractedUser = {};\n  var attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;\n  attributes.forEach(function (key) {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n  return extractedUser;\n}\n/**\n * Normalize data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param options.include An optional array of keys to include in the normalized data. Defaults to\n * DEFAULT_REQUEST_INCLUDES if not provided.\n * @param options.deps Injected, platform-specific dependencies\n * @returns An object containing normalized request data\n */\n\n\nfunction extractRequestData(req, options) {\n  var _ref = options || {},\n      _ref$include = _ref.include,\n      include = _ref$include === void 0 ? DEFAULT_REQUEST_INCLUDES : _ref$include,\n      deps = _ref.deps;\n\n  var requestData = {}; // headers:\n  //   node, express, koa, nextjs: req.headers\n\n  var headers = req.headers || {}; // method:\n  //   node, express, koa, nextjs: req.method\n\n  var method = req.method; // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n\n  var host = req.hostname || req.host || headers.host || '<no host>'; // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n\n  var protocol = req.protocol === 'https' || req.socket && req.socket.encrypted ? 'https' : 'http'; // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n\n  var originalUrl = req.originalUrl || req.url || ''; // absolute url\n\n  var absoluteUrl = \"\".concat(protocol, \"://\").concat(host).concat(originalUrl);\n  include.forEach(function (key) {\n    switch (key) {\n      case 'headers':\n        {\n          requestData.headers = headers;\n          break;\n        }\n\n      case 'method':\n        {\n          requestData.method = method;\n          break;\n        }\n\n      case 'url':\n        {\n          requestData.url = absoluteUrl;\n          break;\n        }\n\n      case 'cookies':\n        {\n          // cookies:\n          //   node, express, koa: req.headers.cookie\n          //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          requestData.cookies = // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can\n          // come off in v8\n          req.cookies || headers.cookie && deps && deps.cookie && deps.cookie.parse(headers.cookie) || {};\n          break;\n        }\n\n      case 'query_string':\n        {\n          // query string:\n          //   node: req.url (raw)\n          //   express, koa, nextjs: req.query\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          requestData.query_string = extractQueryParams(req, deps);\n          break;\n        }\n\n      case 'data':\n        {\n          if (method === 'GET' || method === 'HEAD') {\n            break;\n          } // body data:\n          //   express, koa, nextjs: req.body\n          //\n          //   when using node by itself, you have to read the incoming stream(see\n          //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n          //   where they're going to store the final result, so they'll have to capture this data themselves\n\n\n          if (req.body !== undefined) {\n            requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n          }\n\n          break;\n        }\n\n      default:\n        {\n          if ({}.hasOwnProperty.call(req, key)) {\n            requestData[key] = req[key];\n          }\n        }\n    }\n  });\n  return requestData;\n}\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\n\n/**\n * Add data from the given request to the given event\n *\n * @param event The event to which the request data will be added\n * @param req Request object\n * @param options.include Flags to control what data is included\n * @param options.deps Injected platform-specific dependencies\n * @hidden\n */\n\n\nfunction addRequestDataToEvent(event, req, options) {\n  var include = _objectSpread({}, DEFAULT_INCLUDES, _optionalChain([options, 'optionalAccess', function (_) {\n    return _.include;\n  }]));\n\n  if (include.request) {\n    var extractedRequestData = Array.isArray(include.request) ? extractRequestData(req, {\n      include: include.request,\n      deps: _optionalChain([options, 'optionalAccess', function (_2) {\n        return _2.deps;\n      }])\n    }) : extractRequestData(req, {\n      deps: _optionalChain([options, 'optionalAccess', function (_3) {\n        return _3.deps;\n      }])\n    });\n    event.request = _objectSpread({}, event.request, extractedRequestData);\n  }\n\n  if (include.user) {\n    var extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, include.user) : {};\n\n    if (Object.keys(extractedUser).length) {\n      event.user = _objectSpread({}, event.user, extractedUser);\n    }\n  } // client ip:\n  //   node, nextjs: req.socket.remoteAddress\n  //   express, koa: req.ip\n\n\n  if (include.ip) {\n    var ip = req.ip || req.socket && req.socket.remoteAddress;\n\n    if (ip) {\n      event.user = _objectSpread({}, event.user, {\n        ip_address: ip\n      });\n    }\n  }\n\n  if (include.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, include.transaction);\n  }\n\n  return event;\n}\n\nfunction extractQueryParams(req, deps) {\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  var originalUrl = req.originalUrl || req.url || '';\n\n  if (!originalUrl) {\n    return;\n  } // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.\n\n\n  if (originalUrl.startsWith('/')) {\n    originalUrl = \"http://dogs.are.great\".concat(originalUrl);\n  }\n\n  return req.query || typeof URL !== undefined && new URL(originalUrl).search.replace('?', '') || // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node\n  deps && deps.url && deps.url.parse(originalUrl).query || undefined;\n}\n\nexport { addRequestDataToEvent, addRequestDataToTransaction, extractPathForTransaction, extractRequestData };","map":null,"metadata":{},"sourceType":"module"}